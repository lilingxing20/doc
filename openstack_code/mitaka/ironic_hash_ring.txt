# Ironic 一致性 Hash 算法

## Hash 环构造过程

1. 首先 Ironic 获取所有 online 的 conductor 节点；
2. 根据 conductor 支持的驱动，把 conducor 划到不同的组里；
   存为字典结构： {driver_name1: [host1, host2], driver_name2: [host2, host3]}

   注解：当一个 conductor 配置支持多个驱动时，这个 conductor 会出现在不同组里。

3. 每个驱动创建一个 Hash 环，环的默认大小是 2^5。
   Hash 环的大小可以通过配置项 hash_partition_exponent 修改，默认是5。

4. 将某个驱动所有的 conductor 节点加入到 Hash 环上；
4.1 将 conductor 的 hostname 进行 utf-8 编码，得到一个 key;
4.2 将 key 做 md5 运算，得到一个 key_hash;
4.3 key_hash.update(key);
4.4 取 key_hask 的十六进制字符串并转换成整数 Ci;
4.5 把所有得到的 Ci 整数 按大小排序，并保存到 partitions 数组中;


## Node 映射到 Conductor
1. 根据 node 驱动找到对应的 Hash 环;
   注解：每次操作时，Hash 都会重新生成，防止某个 conductor 离线而导致操作失败。

2. 根据 node_uuid hash 算出 hashed_key, 算法同上面;
3. 根据 hashed_key 在上面构造的 partitions 数组中找到合适的位置 p;
4. 根据位置 p 获取 Conductor 节点。


## 示例

假设有三个 conductor 节点， 节点的 hostname 分别是: conductor1, conductor2, conductor3. 这三个 conductor 都支持 pxe_ipmitool 驱动。

首先根据 hostname 构造一个 Hash 环（hash_partition_exponent=2）。
_host_hashes = {
230240344715403454333456498039283980478L:'conductor2',
54059026899604199202964326694290294767L:'conductor1',
260454599396158325907132773459683028090L:'conductor3',
298021895303194689411369416056237986934L:'conductor2',
182324482847865434399942638425021924949L:'conductor1',
132023576688182125904166825961675080271L:'conductor3',
135337946263003856674732806147013468695L:'conductor2',
18418854993327888888515357194113844682L:'conductor1',
182292343430215611141732563975516737921L:'conductor3',
127036576124465547153494026765150030322L:'conductor3',
36296998252068438004496380639615999813L:'conductor2',
119175164063930766681028679144408032873L:'conductor1'
}

_partitions = [
18418854993327888888515357194113844682L,
36296998252068438004496380639615999813L,
54059026899604199202964326694290294767L,
119175164063930766681028679144408032873L,
127036576124465547153494026765150030322L,
132023576688182125904166825961675080271L,
135337946263003856674732806147013468695L,
182292343430215611141732563975516737921L,
182324482847865434399942638425021924949L,
230240344715403454333456498039283980478L,
260454599396158325907132773459683028090L,
298021895303194689411369416056237986934L
]

然后根据 Ironic node 的 uuid(f76e827e-f960-4a96-abd5-ced5103c7d37) hash 出一个 position, 离这个 position 最近的 conductor 就是要找的节点。
注解：如果希望异常是快速恢复，可以通过配置 hash_distribution_replicas 调度多个 conductor，默认 hash_distribution_replicas=1。
# python
Python 2.7.5 (default, Oct 11 2015, 17:47:16) 
[GCC 4.8.3 20140911 (Red Hat 4.8.3-9)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
>>> import hashlib
>>> import bisect
>>> _partitions = [18418854993327888888515357194113844682L, 36296998252068438004496380639615999813L, 54059026899604199202964326694290294767L, 119175164063930766681028679144408032873L, 127036576124465547153494026765150030322L, 132023576688182125904166825961675080271L, 135337946263003856674732806147013468695L, 182292343430215611141732563975516737921L, 182324482847865434399942638425021924949L, 230240344715403454333456498039283980478L, 260454599396158325907132773459683028090L, 298021895303194689411369416056237986934L]
>>> _host_hashes = {230240344715403454333456498039283980478L: 'conductor2', 54059026899604199202964326694290294767L: 'conductor1', 260454599396158325907132773459683028090L: 'conductor3', 298021895303194689411369416056237986934L: 'conductor2', 182324482847865434399942638425021924949L: 'conductor1', 132023576688182125904166825961675080271L: 'conductor3', 135337946263003856674732806147013468695L: 'conductor2', 18418854993327888888515357194113844682L: 'conductor1', 182292343430215611141732563975516737921L: 'conductor3', 127036576124465547153494026765150030322L: 'conductor3', 36296998252068438004496380639615999813L: 'conductor2', 119175164063930766681028679144408032873L: 'conductor1'}
>>> len(_partitions)
12
>>>
>>> data = '4843c44d-adfd-406f-897b-7ff9abf79dc6'
>>> key_hash = hashlib.md5(data)
>>> key_hash.hexdigest()
'559ba9f4970abb1c14d570fe42dd936f'
>>> hashed_key = int(key_hash.hexdigest(), 16)
>>> hashed_key
113792632760430627433807459609904780143L
>>> position = bisect.bisect(_partitions, hashed_key)
>>> position
3
>>> position = position if position < len(_partitions) else 0
>>> position
3
>>> _host_hashes[_partitions[position]]
'conductor1'
